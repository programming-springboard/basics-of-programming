# Foreword (in English)

This repository contains the Basics of Programming course I have made for my friends as they showed their desire to study programming. Therefore, the course is now available only in Russian as I do not have any time or desire to translate it into English and all of us are native Russian speakers. If you want to help me with translations - feel free to open up any pull requests.

# Курс "Основы программирования"

Этот курс предназначен для изучения теми, кто только начинает свой путь в программировании, не знает еще ни одного из языков программирвоания и самых базовых конструкций, присущих им. Не нужно воспринимать этот курс в отрыве от других, созданных в рамках проекта Programming Springboard. Он является лишь одной ступенью на длинном пути от новичка до Backend разрабочтика на языке Python.

В рамках этого курса Вы:

- ознакомитесь с понятием программирования, его базовыми терминами;
- выучите основные конструкции языка С, присущие большинству языков программирования (переменные, типы данных, логические операции, циклы, функции);
- выучите на примерах структурный подход к программированию.

## Прежде, чем мы начнем ...

Сам я пользуюсь (и всем советую) операционной системой Linux (конкретнее, её дистрибутивом Ubuntu). Все примеры консольных команд, которые будут приводится в рамках этого курса, были выполнены в терминале Ubuntu 20.04.

Этот совет, конечно же, носит рекомендательный характер. Когда я сам начинал учить программирование, делал я этот на Winbdows XP, которая тогда стояла у меня на домашнем компьютере. Ubuntu и Linux ни в коем случае не являются "серебрянной пулей" (но могут явно упростить Вам жизнь). Для задач учебы/работы вполне сойдет и любой другой дистрибутив Linux'a или же вовсе другая UNIX-подобная операционная система, например, MacOS или FreeBSD.

## Содержание

Ниже приведен список тем, рассматриваемых в рамках этого курса, с кликабельными ссылками:

1. [Введение в программирование](#введение-в-программирование)
2. [Создание первой программы](#создание-первой-программы)
3. [Переменные](#переменные)
4. [Ввод и вывод информации в консоли](#ввод-и-вывод-информации-в-консоли)
5. [Стандартные математические операции](#стандартные-математические-операции)
6. [Логические операции](#логические-операции)
7. [Сложные математические операции](#сложные-математические-операции)
8. [Циклы](#циклы)
9. [Указатели](#указатели)
10. [Массивы](#массивы)

# Введение в программирование

На первом, вступительном уроке разбирается само понятие программирования, а также дается базовое введение в язык Си (англ. "С"). На примерах показывается, как инициализироват ьпеременные разных типов, как взаимодействовать с портами ввода-вывода системы, разбираются основные логические операции.

## Что есть программирование?

**Программирование** - процесс написания компьютерных программ. Компьютерные программы, в свою очередь, представляют из себя описание алгоритмов, выполняемых над определенными данными (структурами данных). Описание это формализуется с помощью различных языков программирования.

Создание компьютерных программ можно сравнить с написанием кулинарных рецептов. В обоех случаях, описывается определенный порядок действий для решения конкретной задачи (или класса задач; в случае с готовкой - задача приготовления пищи). Исполнителями кулинарных рецептов являются люди, повара. Исполнителями программ являются компьютеры.

## Языки программирования

Компьютер достаточно простая машина, которая понимает только язык нулей и единиц. Понятное дело, что описывать все мельчайшие инструкции, пользуясь только двоичной системой исчисления было бы долго и скучно  (*но не невозможно!*). Языки программирования представляют из себя некий компрмисс - они представляют собой правила написания инструкций, которые могут быть поняты как человеком, так и компьютером.

### Язык C

Для курсов основ программирования я решил выбрать язык *С*. Отсюда может последовать логичный вопрос: "Виталик, ведь ты же Python разработчик! Почему бы нам не начать с него? Зачем нам учить *С*?". Ответ будет прост. *С* очень **низкоуровневый** язык. Это означает, что инструкции, которые вы на нем пишите, более приближены к аппаратному уровню в сравнении с другими языками.


# Создание первой программы

Сразу оговорюсь, что все команды терминала, которые запускаются по ходу этого урока - запускаются под ОС Linux (Ubuntu 20.04).

Для начала, нам необходимо создать файл исходного кода. Файлы исходного кода языка *С* имеют расширение `.c`. По своей структуре, это обычные текстовые файлы (такие же, как например `.txt`, или файлы с любым другим исходным кодом). Принято их обозначать `.c` по следующим причинам:

1. Чтобы операционные системы могли распознавать, какой программой (редактором кода/интегрированной средой разработки) лучше всего открывать этот файл.
2. Чтобы редакторы кода могли правильно подвечивать синтаксис (а иногда и давать контекстные подсказки в автодополнении кода).

## Создание файла с исходным кодом

Итак, запишем нашу первую программу в `program.c`:

```bash
touch program.c
```

Я буду редактировать её с помощью консольного текстового редактора `vim`. Вы же для себя можете выбрать любой подходящий инструмент. Об альтернативах я расскажу немного позже.

Запишем в файл `program.c` следующее.

```c
int main() {
    return 0;
}
```

Выше вы можете наблюдать самый минимальный программный код, который вам придется написать на языке *С*. Здесь приводится описание главной функции `int main ()` - точки входа в программу. Как только ваша программа запустится, будет выполнен код блок кода, заключенный в символы `{}`. В данном случае, выполнится строка `return 0;`. Ключевое слово `return` обозначает конец выполнения функции и указывает программе вернуть после своего выполнения код 0. Код 0 обозначает, что программа завершилась удачно. Если операционная система получит любой ненулевой код - это будет означать, что ваша программа завершилась ошибкой.

Обратите внимание, что в конце каждой инструкции нужно ставить `;`.

## Компиляция

Сколько не кликай по файлу исходного кода - он так и не перестанет открываться текстовым редактором. Но ведь мы написали программу не для того, чтобы на неё любоваться? Мы хотели сделать так, чтобы её прочитал компьютер. Для этого нам необходимо воспользоваться услугами **компилятора** - условного сборщика программного кода, который перевод исходный текст программы в инструкции, понятные компьютеру.

Я буду использовать бесплатный свободно распростряняемый компилятор [GCC](https://gcc.gnu.org/).

Для того, чтобы скомпилировать наш программный файл необходимо выполнить следующую команду:

```bash
gcc program.c -o program
```

Первым параметром мы передаем `program.c` - путь к исходному коду программы. Через параметр `-o` мы указываем путь, по которому будет записана скомпилированная программа. В данном случае, это `program`. Для того, чтобы запустить эту программу необходимо выполнить:

```bash
./program
```

На данный момент наша программа ничего не делает. Она просто запускается и сразу же завершается с кодом 0.

В следующих уроках мы добавим в эту программу немного действия: заставим её складывать несколько чисел.

# Переменные

**Переменные** - это некие именованные области памяти, которые содержат в себе определенное значение. Значения бывают разних типов. Типы эти надо указывать при объявлении переменной.

Давайте, для примера, объявим в нашем коде переменную `a`, которая будет хранить в себе целочисленные значения.

```c
int main() {
    int a;
    return 0;
}
```

В данном случае, `int` - это объявление типа данных для переменной `a`. В языке *С* существуют следующие типы данных:

Тип данных | Описание | Минимальный размер в байтах
-----------|----------|----------------------------
char | Тип данных для хранения отдельных символов | 1
int | Тип данных для хранения целых чисел | 2
float | Тип данных для хранения дробных чисел | 4 (зависит от системы)
double | Тип данных для хранения дробных чисел двоичной точности | 8 (зависит от системы)

Существуют также модификаторы типов данных. Они, например, могут управлять максимальным размером, который может хранить переменная в байтах или тем, какие значения может хранить переменная. Определенные модификаторы можно применять только к определенным типам данным (см. таблицу ниже).

Модификатор | Описание | К каким типам можно применять
------------|----------|------------------------------
unsiged | Указывает, что переменная может содержать только значения без знака (подразумевается знак минус). Так, например `unsiged int` может содержать только положительные числа и 0 | `char`, `int`
signed | Указывает, что переменная может содержать значения как со знаком, так и без него. Модификатор `signed` используется по умолчанию и указывать его надо только для того, чтобы явно указать, что переменная может принимать значения как больше, так и меньше нуля | `char`, `int`
short | В 2 раза уменьшает размер значения в байтах, которое может содержать эта переменная. Модификатор `short` может использоваться как самостоятельный тип данных (`short a` равносильно записи `short int a`; **заметка**: поскольку `short` может быть использован как самостоятельный тип данных, к нему также можно применять другие модификаторы: `short`, `signed`, `unsiged`, `long`) | `int`
long | В 2 раза увеличивает размер значения в байтах, которое может содержать переменная. Подобно `short`, модификатор `long` может быт ьиспользован как самостоятельный тип данных и равносилен записи `long int` | `int`, `double`

Полный список всех типов данных *С* с их размерами и описанием можете также посмотреть в [статье на Википедии](https://en.wikipedia.org/wiki/C_data_types#Main_types).

## Значения переменных

Как уже было сказано раньше, переменные используются для хранения *значений*. Вернемся к нашему прошлому примеру и присвоим переменной `a` значение `2`.

```c
int main() {
    int a;
    a = 2;
    return 0;
}
```

Присваивать значение переменной можно сразу после её объявления:

```c
int main() {
    int a = 2;
    return 0;
}
```

Можно также объявлять сразу несколько переменных:

```c
int main() {
    int a = 2, b = 3;
    return 0;
}
```

Но только если они имеют один и тот же тип. В противном случае, объявлять их надо следующим образмом:

```c
int main() {
    int a = 2;
    short b = 3;
    return 0;
}
```

Пример инициализации переменных всех типов:

```c
int main() {
    int integer = 2;
    short shortInteger = 3;
    long longInteger = 4;
    long long superLongInterger = 999;

    // Целую часть от дробной необходимо отделять точкой
    float floatingPointNumber = 1.3;
    double floatingPointNumberWithDoublePrecision = 2.7;

    // При объявлении символьных переменных, значения необходимо указывать в
    // одинарных кавычках '
    // Двойные кавычки используются для записи последовательности символов
    // Например, "word".
    // Работу с последовательностями символов мы рассмотрим позже.
    char character = 'c';

    return 0;
}
```

Текст, написанный после `//` считается комментариями к коду - он никак не вляется на результат выполнения программы и игнорируется компилятором во время его работы. Комментарии очень важны в программах, т.к. дают возможность другим программистам понять какие-то неявные решения, которые вы приняли во время написания программы (не говоря уже о том, что этим программистом можете быть Вы из будущего).

## Сложение

Пускай мы и объявили много переменных, наша программа все еще не делает ничего полезного. Давайте, для примере, заставим её считать сумму двух чисел.

```c
int main() {
    int a = 3, b = 4;
    // Произведем сложение значений в переменных a и b: a + b
    // После чего занесем результат сложения (в данном случае, 7) в
    // переменную sum.
    int sum = a + b;
    return 0;
}
```

Заново скомпилируем и выполним наше приложение. Напоминаю, сделать это можно выполнив следующее:

```shell script
gcc program.c -o program
./program
```

И -.. Наша программа все еще ничего не выводит. Дальше мы разберемся, как взаимодействовать с портами вывода.

# Ввод и вывод информации в консоли

В этом уроке мы разберемся, как взаимодействовать с портами ввода-вывода в языке *С*.

## Вывод информации в консоль

За вывод информации в консоль в языке *С* отвечает функция `printf`. Прежде, чем разобрать её на примере необходимо немного рассказать о функциях.

**Функции** это переиспользуемый набор операций. В стандартной библиотеке языка *С* имеется множество функций для решения типичных проблем, которые возникают в процессе написания программного обеспечения.

Прежде чем использовать функции из стандартной библиотеке, необходимо подключить нужный заголовочный файл стандартной библиотеки, который описывает эту функцию. Делается это с помощью команды `#include`.

### Hello world

Обычно, во время изучения новых языков программирование, первое, что вы делаете - это пишите программу, которая печатает в консоль одно единственно сообщение: **Hello world**. Таким образом вы учитесь запускать программы, написанные на этом языке программирования и, увидев заветное сообщение в консоли, с легкостью вздыхаете, что все прошло хорошо. В нашем курсе я решил начать обучение с изучения типов данных и сложения переменных. Концепция написания **Hello world** подходит для второго и дальнейших языков, когда вы уже знакомы с базовыми принципами программирования и какими-то общими шаблонами языков программирования, присущих большинству из них.

Пример *Hello world* программы на *С*:

```c
// Подключаем заголовочный файл для работы с вводом выводом.
// std в названии означает, что файл является частью стандартной библиотеки
// io - сокращение от input/output
#include <stdio.h>

// Обратите также внимание, что заголовнчые файлы подключаются в самом верху
// файла с исходным кодом, за пределеами функции main.

int main() {
    // Для вызова функции необходимо после её названия добавить (). Внутри этих
    // скобочек необходимо перечислить все аргументы, которые принимает эта
    // функция.

    // В данном примере, единственным аргументом является последовательность
    // Символов "Hello world\n".
    printf("Hello world\n");
    return 0;
}
```

Скомпилируем и выполним программу. При запуске она выводит в консоль следующее сообщение:

```
Hello world
```

### Символ \n

В конце стоки я намеренно добавил `\n`. Это символ переноса строки. Попробуйте убрать его из программы и посмотрите на результат.

В языке *С* имеется несколько специальных символов: `\t` для установки знака табуляции, `\r` - символ переноса каретки. Более подробную информацию вы можете найти [здесь](https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences).

Символ `\` также используется для *экранирования* других специальных символов. Например, вы не сможете так просто написать `"` посреди другой строки - это просто закроет вашу предыщую строку и весь текст после вставленного символа `"` окажется вне вашего сообщения, что вызовет ошибку компиляции. Т.е., чтобы напечатать `Hello "world"` в консоль необхъодимо будет передать следующую строку первым параметром в функцию `printf`: `"Hello, \"world\"\n"`. Экранировать можно любой символ, даже саму наклонную черту. Так, например, `printf("\\")` выведет на экран `\`.

### Форматирование строк

Иногда, содержание строки, которая будет выведена на экран, по логике должно формироватся в момент выполнения программы. Вернемся к нашему предыдущему примеру со сложением читсел. Каким образом мы можем вывести на экран сообщение `a + b = %рассчитанная_сумма%`? С помощью форматирования строк!

```c
int main() {
    int a = 3, b = 4;
    int sum = a + b;
    printf("a + b = %d\n", sum);
    return 0;
}
```

В данном случае, программа выведет на экран сообщение `a + b = 7`. Значение переменной `sum` подставилось на место `%d` в строке. Во время написания самой строки мы зарезервировали это место под значение переменной. Все "резервные места" начинаются с символа `%`, далее идет идентификатор, в данном случае `d` (англ. "decimal" - десятичное). Такие "резервные места" называются спецификаторами формата. Существуют и другие спецификаторы, такие как, например: `%c` для вставки символов, `%f` для вставки чисел с плавающей точкой, `%s` для подстановки строк. Полный список, как всегда, можете найти по [ссылке](http://www.cplusplus.com/reference/cstdio/printf/).

Обратите внимание, что мы передали `sum` вторым аргументом в функцию `printf`. Аргументы разделяются между собой запятой: `arg1, arg2`.

Форматированная строка может содержать в себе сколь-угодно много спецификаторов формата. Главнео помните - каждому из них должно соответстовать значение, переданное как аргумент в функцию `printf`:

```c
int main() {
    int a = 3, b = 4;
    int sum = a + b;
    printf("%d + %d = %d", a, b, sum);
    return 0;
}
```

Программа выше выведет следующее сообщение в консоль:
```
3 + 4 = 7
```

Порядок аргументов очень важен. Так, значение переменной `a` подставилось на первую позицию `%d`, `b` - на вторую и так далее.

Спецификаторы формата можно совмещать между собой. Так, строка для форматирования спокойно может иметь вид `"%s: %d - %d = %f"`.

## Ввод данных из консоли

Для того, чтобы считать данные из консоли используется функция `scanf`. Её интерфейс подобен функции `prinft`: первым параметром указываем формат, в котором считываем данные, вторым параметром - переменную, в которую необходимо записать считанные данные. Разберем на примере:

```c
#include <stdio.h>

int main() {
    int a;

    // Запрашиваем пользователя ввести значение переменной а
    // Это сообщение не обязательно, но таким образом мы показываем
    // пользователю, что ожидаем его ввод
    printf("Enter a: ");

    // Перед именем переменной необходимо также оставить знак &, как показано
    // в примере.
    // Спецификаторы формата тут используются те же, что и в printf функции.
    scanf("%d", &a);

    // Выведем введенное значение обратно пользователю в консоль
    printf("a value is %d\n", a);
    return 0;
}
```

# Стандартные математические операции

Рассмотрим встроенные математические операции на примере:

```c
int main() {
    int a = 7, b = 5;

    int sum = a + b; // 12
    int diff = a - b; // 2
    int product = a * b; // 35
    int division = a / b; // 1
    int mod = a % b; // 2

    int incrementedAfter = a++; // incrementedBefore = 7, a = 8
    int decrementedAfter = a--; // decrementedBefore = 8, a = 7

    int incrementedBefore = ++a; // incrementedAfter = 8, a = 8
    int decrementedBefore = --a; // incrementedAfter = 7, a = 7

    a += 2; // Тоже самое, что и a = a + 2; a теперь 9
    a -= 2; // Тоже самое, что и a = a - 2; а теперь 7
    a *= 2; // Тоже самое, что и a = a * 2; а теперь 14
    a /= 2; // Тоже самое, что и a = a / 2; а теперь 7

    return 0;
}
```

## Деление

Как вы могли заметить, при делении 7 на 5 мы получили в результате один. Дело в том, что разделяя одну переменную типа `int` на другую мы также получаем тип `int` в результате, который не может иметь никакого дробного остатка. В итоге, результат деления округляется. Округление всегда происходит в меньшую сторону, таким образом вместо желаемых `1.4` мы в итоге получили `1`.

Операция `%` возвращает остаток от деления. Деление с остатком некого числа `a` на `b` представляет собой нахождения таких чисел `q` и `r`, что выполняется уравнение `a = b * q + r`, где `q` - это неполное частное, `r` - остаток от деления. Остаток от деления должен быть обязательно больше или равен 0 и меньше b.

В нашем случае, неполным частным является `1`(то самое значение, которое мы получили в результате выполнения `a / b`), а остаток от деления - `2`. Таким образом `7 = 5 * 1 + 2`.

Рассмотрим другие примеры для наглядности:

```
5 % 2 = 1; q в данном случае равняется 2
10 % 4 = 2; q = 2
25 % 5 = 0; q = 5
```

Если все еще не понятно - советую обратися к [Википедии](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%BE%D0%BC).

## Операторы инкремента и декремента

Оператор инкремента `++` и декремента `--` может быть записан в двух формах:

- префиксальной: `++a`, `--a`;
- суффиксальной: `a++`, `a--`.

При выполнении простой строчки `a++;` или `++a;` порядок написания не играет никакого значения. Разница видна только во время присвоения. Как мы видим из примера, если унарные операторы записаны в качестве суффикса, то сначала выполнится операция присвоения `var = a` и только затем операция инкремента\декремента. В случае, если операторы записаны в качестве префикса, то сначала будет выполнен этот оператор и только потом операция присвоения.

# Логические операции

Для проверки логических конструкций в языке *С* используется конструкция if-else: `if (условие) выполнить; else выполнить другое;` (`else`-часть при этом опциональна и может не указываться). Давайте разберем на примере, как проверить, что одно число больше другого:

```c
#include <stdio.h>

int main() {
    int a = 7, b = 5;

    if (a > b)
        printf("a is bigger than b\n");

    return 0;
}
```

Давайте немного модернезируем наш пример: теперь значения `a` и `b` будут вводится пользователем с клавиатуры. В зависимости от того, `a > b` или нет, программа будет выводить разные сообщения:

```c
#include <stdio.h>

int main() {
    int a;
    printf("Enter a: ");
    scanf("%d", &a);

    int b;
    printf("Enter b: ");
    scanf("%d", &b);

    if (a > b)
        printf("a is bigger than b\n");
    else
        printf("a is less than b\n");

    return 0;
}
```

Однако, в нашем примере все еще остается не рассмотрена одна ситуация: случай, когда `a` и `b` равны. Обработаем и его:

```c
if (a > b)
    printf("a is bigger than b\n");
else if (a == b)
    printf("a equals to b\n");
else
    printf("a is less than b\n");
```

Обратите внимание, что для равенства используется оператор `==`, т.к. оператор `=` уже занят для присвоения значений.

Значение `0` всегда будет не истинным. Любое ненулевое значение всегда будет означать правду: `if (1)` будет выполняться всегда, `if (0)` не выполнится никогда.

Представим также ситуацию, что мы хотим выполнить сразу несколько дейсвтий, если одно из условий оказалось правильным:

```c
if (a > b) {
    printf("a is bigger than b\n");
    int sum = a + b;
    printf("a + b = %d\n", sum);
}
```

Это также работает и для других частей конструкции:

```c
if (a > b) {
    // Какой-то код..
} else if (a == b) {
    // Другой код
} else {
    // Абсолютно другой код
}
```

Код, заключенный в фигурные скобки `{}` называется блоком кода и он имеет ограниченную область видимости. Это означает, что любые переменные, объявленные внутри этого блока кода не будут видимы за его пределами:

```c
if (a > b) {
    int sum = a + b;
}

// Ошибка компиляции, переменная sum не видна в этом контексте
printf("%d", sum);
```

В то же время следующий код будет правильным:

```c
int sum = 0;

if (a > b) {
    sum = a + b;
}

// Не вызовет ошибки, т.к. sum была определена в этом же контексте
printf("%d", sum);
```

## Логические операторы

Представим ситуацию, что нам надо проверить сразу несколько условий. Например, `0 < a < b`. Записать это можно как `a > 0 and a < b`:

```c
if (a > 0) {
    if (a < b) {
        // Код
    }
}
```

Но сделать это можно намного проще с помощью логического "И": оператора `&&`.

```c
if (a > 0 && a < b) {
    // Код
}
```

Есть также оператор логическое "ИЛИ": оператор `||`:

```c
if (a > 0 || a < b) {
    // код, который выполнится, если а > 0 или a < b
}
```

Для того, чтобы проверить противоположное предположение есть оператор логического "НЕТ": `!`:

```c
if (!(a > 0)) {
    // Код, который выполнится, если a <= 0.
    // Обратите внимание, что (a > 0) заключено в скобки, чтобы оператор !
    // относился ко всему выражению, а не только к переменной а
}
```

## Все операторы сравнений

Ниже приведен список всех логических операторов сравнения:

- `a > b`: `a` больше `b`;
- `a < b` `a` меньше `b`;
- `a >= b` `a` больше или равен `b`;
- `a <= b` `a` меньше или равен `b`;
- `a == b` `a` равен `b`;
- `a != b` `a` не равен `b`.

## Конструкция switch-case

Представим ситуацию, что у нас есть некоторое перечисление состояний определенного объекта. Для примера скажем, что у нас есть объект "заявка", которая может принимать значения отклонена (0), на рассмотрении (1) или принята (2). Проверим значение переменной, которая указывает на состояние объекта и в зависимости от этого значение напишем состояние заявки в чат:

```c
#include <stdio.h>

int main() {
    int state;
    printf("Input request status: ");
    scanf("%d", &state);

    if (state == 2) {
        printf("Request is approved\n");
    } else if (state == 1) {
        printf("Request is processing\n");
    } else if (state == 0){
        printf("Request is cancelled\n");
    } else {
        printf("Invalid request status\n");
    }

    return 0;
}
```

Подобную конструкцию можно было бы переписать с помощью конструкции switch-case:

```c
#include <stdio.h>

int main() {
    int state;
    printf("Input request status: ");
    scanf("%d", &state);

    switch (state) {
        case 2:
            printf("Request is approved\n");
            break;
        case 1:
            printf("Request is processing\n");
            break;
        case 0:
            printf("Request is cancelled\n");
            break;
        default:
            printf("Invalid request status\n");
            break;
    }

    return 0;
}
```

Как видите, каждое состояние описывается блоком `case`. В конце каждого блока `case` необходимо оставлять инструкцию `break`, которая будет сообщать об окончании `case`-блока. Блок `default` будет выполнен в том случае, если значение `state` не соответствует ни одному `case`. Блоки `case` и `default` могут содержать сколь-угодно инструкций, главное правило - `break` в конце.

# Сложные математические операции

[Ранее](#стандартные-математические-операции) мы уже рассматривали как выполнять простые математические операции на языке *С*. Теперь же пришло время расширить свой кругозор, пополнив его математическими функциями из библиотеки `math.h`, которая позволяет работать с логарифмами, абсолютными величинами, возводить числа в нужную степень, извлекать корень квадратный и выполнять тригонометрические функции (sin, cos, tg, ctg и др). Давайте рассмотрим следующий пример с комментариями:

```c
#include <math.h>

int main() {
    int a = 3, b = 4;

    // Все функции из библиотеки math.h принимают в качестве своих параметров
    // числа типа double, однако, если мы передадим туда значения типа int
    // они автоматически будут приведены к double
    double aPoweredByB = pow(a, b); // Возводит a в степень b

    double sinA = sin(a); // Синус а (где а - значение в радианах)
    double cosB = cos(b); // Косинус b (где b - также значение в радианах)

    // Другие полезные функции
    double sqrtA = sqrt(a); // Корень квадратный из числа a
    double absA = fabs(a); // Абсолютное значение а (т.е. значение по модулю)

    return 0;
}
```

Полный список всех математических функций с описанием можно найти по [ссылке](https://www.tutorialspoint.com/c_standard_library/math_h.htm).

# Циклы

В программировании часто возникает необходимость обобщить какие-то повторяемые участки кода. Когда некоторое действие необходимо выполнить определенное количество раз, в бой идут *циклы*.

## Программирование без циклов

Рассмотрим для начала пример программы, в которой не используются циклы. Предположим у нас есть какой-то таймер, который дает обратный отсчет к выполнению необходимого нам действия (обратите внимание, что в примере используется функция `sleep`, которая заставляет программу "заснуть" на переданное количество секунд, в данном примере - `1`):

```c
#include <stdio.h>
#include <unistd.h> // Библиотека для sleep

int main() {
    printf("3 seconds remaining ...\n");
    sleep(1);

    printf("2 seconds remaining ...\n");
    sleep(1);

    printf("1 seconds remaining ...\n");
    sleep(1);

    printf("Something has happened!\n");
    return 0;
}
```

Как мы видим, после каждого сообщения `remaining` у нас выполняется одна и та же функция `sleep(1)`. Кроме того, сами сообщения отличаются лишь 1й цифрой в начале, что можно было бы как-то параметризировать. О том, как это сделать - поговорим дальше.

## Цикл while

Рассмотрим теперь пример выполнения этой же задачи, только с использованием конструкции `while` - условного цикла:

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    int seconds = 3;
    while (seconds > 0) {
        printf("%d seconds remaining ...\n", seconds)
        seconds--;
    }
    printf("Something has happened!\n");
    return 0;
}
```

В структуре `while` внутри скобок записывается условие выполнения (подобно тому, как записывается условие в конструкции `if`). Цикл будет выполняться до тех пор, пока условие его выполнения будет выполняться.

## Цикл for

Как вы могли заметить, из всего цикла нас интересует только сообщение `%d seconds remaining ...`. Все остальное: объявление переменной `seconds`, условие выполнения `seconds > 0`и уменьшение переменной после вывода сообщения на экран `seconds--` - просто способ описания.

Описать эти три этапа можно с помощью цикла `for`. Рассмотрим сразу на примере:

```c
for (int seconds = 3; seconds > 0; seconds--) {
    printf("%d seconds remaining ...\n", seconds);
}
```

Как вы видите, конструкция `for` представляет из себя запись `for (;;)` (кстати, в таком случае цикл будет выполняться бесконечно). На первой позиции мы указываем действие, которое выполнится один раз *перед* выполнением цикла. На втором месте у нас *условие выполнения*, такое же, как было в цикле `while`. На третьем - действие, выполняемое *после* каждой итерации. Так `seconds--` будет выполнен каждый раз после `printf("%d seconds remaining ...\n", seconds)`.

## Цикл do-while

Как вы могли заметить, что в цикле `for`, что в цикле `while` сначала проверяется условие выхода из цикла и только потом происходит итерация. Однако, бывают ситуации. когда нам надо, чтобы цикл выполнился хотя бы 1 раз и потом было проверено условие. Для этого существует цикл с пост-условием `do-while`. Он может быть полезен, например, чтобы валидировать вводимые входные данные через консоль пользователем.

Ниже приведен код программы, которая проверяет, что введенное пользователем число находится в промежутке `(-5; 5)`:

```c
int input;

do {
    printf("Input a number in range (-5; 5): ");
    scanf("%d", &input);
} while (input < -5 || input > 5);

printf("Inputed number: %d\n", input);
```

## break и continue

В языке *С* существует два ключевых слова для управления потоком работы внутри циклов:

- `continue` мгновенно завершает итерацию и переходит к следующей;
- `break` мгновенно завершает выполнение цикла.

Рассмотрим это все на примерах:

```c
// Данный цикл напечатает: 0 1 2 3 4 5 6 7 8 9
for (int i = 0; i < 10; i++)
    printf("%d ", i);

// Данный цикл напечатает: 0 2 4 6 8
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0)
        continue;
    printf("%d ", i);
}

// Данный цикл напечатает: 0 1 2 3 4 5
for (int i = 0; i < 10; i++) {
    if (i > 5)
        break;
    printf("%d ", i);
}
```

Обратите внимание, что как и в конструкции `if/else` фигурные скобки `{}` можно пропускать, если в теле цикла выполняется всего 1 строка.

# Указатели

Как мы уже выяснили раньше, *переменные* - это именованные области памяти, которые хранят в себе определенное значение. Значение это относится к одному из типов данных. В зависимости от типа данных, размер области памяти, выделяемый под переменные различен.

## Получение адреса переменной

Поскольку переменная это некая область памяи - мы должны уметь найти эту самую область. Сделать это можно с помощью оператора `&` (который, например, мы использовали во время передачи аргументов в функцию `scanf`).

Пример:

```c
#include <stdio.h>

int main() {
    int a = 1;
    printf("A address is %p\n", &a); // A address is %адрес_переменной_а%
    return 0;
}
```

## Указатели

Переменные, которые хранят в себе не значение, а ссылку на область памяти называются указателями (поскольку они "указывают" на эту область памяти). Указатели объявляются как обычные переменные, за исключением того, что перед их объявлением ставится `*` (звездочка):

```c
int a = 1; // Инициализируем переменную а как обычно
int *pointerA = &a; // Указатель pointerA теперь показывает на область памяти
                    // в которой хранится переменная а

printf("A address is %p\n", pointerA); // A address is %адрес_переменной_а%
```

Как вы видите, при выводе адреса переменной в консоль используется спецификтор форматирования `%p` (от слова `pointer`, с англ. *указатель*).

## Зачем объявлять тип данных для указателя?

Почему все указатели не могут объявляются на подобии `pointer ptr = &a`? Как уже было сказано, переменные являются объявленными областями памяти. Получая адрес переменной, мы получаем адрес её первого байта в памяти. Поскольку разные типы данных занимают разный объем памяти, указатель определенного типа знает, какой именно объем памяти требуется для расположение переменной в памяти.

## Получение значения переменной по указателю

Имея в своих руках адрес памяти, мы легко можем считает значение, которое хранится по этому адресу памяти:

```c
int a = 1;
int *pointerA = &a;

printf("A address is %p\n", pointerA); // A address is %адрес_переменной_а%
printf("A is %d\n", *pointerA); // A is 1
```

Обращаясь к указателю и добавляя `*` в начале мы производим операцию *разименования*, то есть получение значения по адресу.

# Массивы

Зачастую в программировании появляется необходимость работать не с отдельно взятыми данными, а с целым набором данных. Во-первых, наборы данных легко обрабатывать циклами. Во-вторых, похожие данные по логике лучше объединять в общие структуры.

В программировании набором однотипных данных фиксированной длинны называется *массив*:

```c
int main() {
    // Тут мы объявляем массив с названием A, который буджет содержать в себе
    // два элемента и сразу же определяем эти два элемента.
    int A[2] = {1, 2};

    // Можно также не указывать размер массива, но только в том случае, если
    // сразу объявляете его содержимое. В таком случае, комплиятор просто
    // автоматически вычислит его длинну. Помните, массивы всегда имеют
    // фиксированную длинну и записать "дополнительное" значение в конец нельзя
    int B[] = {3, 4};

    // Сама переменная А является ничем иным как указателем на начало массива
    // Она выведет на экран адрес начала массива, как это делает обычный указатель
    // В printf
    printf("A start address is %p\n", A); // A start adress is 0x23177181

    // Чтобы получить какой-то элемент массива, надо обратиться к его индексу
    // Индекс - это позиция элемента в массиве, индексы начинаются с нуля

    int a = A[0]; // a = 1
    int b = A[1]; // a = 2
    int c = A[2]; // Выход за пределы массива. Это не вызовет ошибки, но
                  // компилятор будет ругаться о выхоже за пределы массива.


    // Точно также обращаясь по индексу можно изменить значение элемента по
    // этому индексу.
    A[0] = 42; // A теперь {42, 2}

    return 0;
}
```

## Почему индексы начинаются с нуля?

Как мы уже выяснили, переменная массива есть ни что иное, как указатель на начала массива, а индекс - отступ от этого самого начала массива.

Итак, с самого начала мы находимся на адресе первой ячейки. Сколько нам надо отступить ячеек, чтобы оказаться в первой? Правильно, ноль! Чтобы оказаться во второй - надо отступить одну ячейку и так далее. Адрес последней ячейки массива равен `длинна массива - 1`.

## Многомерные массивы

До этого момента мы рассматривали только одномерные массивы. Однако массивы можно разворачивать в бесконечном числе измерений:

```c
// Двухмерный массив, в котором есть 2 строчки и 3 столбца (т.е. в каждой
// строке по 3 элемента)
int A[2][3] = {{1, 2, 3}, {4, 5, 6}};

// Это можно представить как:
// 1 2 3
// 4 5 6

// Доступ к этим элементам также осуществляется по индексам. Давайте попробуем
// взять значение третьего элемента второй строки
// Чтобы перейти ко второй строке, мы обращаемся к индексу 1. Чтобы получить
// третий элемент, мы обращаемся к индексу 2 в строке с индексом 1.
printf("%d", A[1][2]);


// Трехмерный массив объявляется следующим образом
int B[2][3][2] = {{{0, 1}, {2, 3}, {4, 5}}, {{6, 7}, {8, 9}, {10, 11}}};
```

Хочу ометить, что элементы массива не обязательно объявлять в порядке их возрастания. Я так делаю лишь для примера. Массив спокойно может иметь значения `{-52, 1, -153, 267}`. Главное, чтобы это были элементы одного типа.

## Массивы типов double, float и др.

Массивы типов `double`, `float` и других объявляются точно таким же образом:

```c
float floatingArray[] = {1.0, 2.5, 3.1};
double doubleArray[] = {0.5, 5.1};
```

## Массивы типа char

Массивы типа char называются строками. Строки записываются в двойных кавычках:

```c
char name[] = "world";
printf("Hello, %s!\n", name); // Hello, world!
```

Давайте немного рассмотрим программу, которая запрашивает имя пользователя и приветствует того:

```c
int name[20]; // Резервируем сразу 20 ячеек памяти под вводимое имя
printf("Enter your name: ");
scanf("%s", name); // Допустим, здесь name = "Vitaliy"
                   // Обратите внимание, что поскольку name - это указатель,
                   // нам не надо писать scanf("%s", &name)

printf("Hello, %s!\n", name); // Hello, Vitaliy!
```

Как вы видите, мы выделяли целых 20 ячеек памяти под переменную `name`, хотя имя `Vitaliy` занимает всего 7. Почему же остальные 13 пустых символов не вывелись на экран вместе с `name`? Дело в том, что *С* по умолчанию в конец каждой строки, создаваемой с помощью `"` добавляет специальный символ `\0` - символ конца строки.

Давайте рассмотрим еще один пример, где мы объявляем массив символов более традиционным способом:

```c
int name[] = {'V', 'i', 't', 'a', 'l', 'i', 'y'};
printf("Hello, %s!\n", name); // Выведет: Hello, Vitaliya7123712hasd!
```

Помимо имени `Vitaliy` в консоль вывелась еще какая-то куча мусора. Откуда она взялась? Как я уже сказал ранее, программа ожидает символа `\0` в конце строки, который добавляется туда только при определенном методе записи. В конце определенного нами массива `name` этого символа не оказалось, поэтому программа шла дальше по памяти, пока не встретила `\0` в последовательности символов.

Правильной будет такая запись:

```c
int name[] = {'V', 'i', 't', 'a', 'l', 'i', 'y', '\0'}
printf("Hello, %s!\n", name); // Выведет: Hello, Vitaliy!
```
